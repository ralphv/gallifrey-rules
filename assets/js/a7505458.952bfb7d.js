"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[472],{1728:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>d});var s=i(4848),n=i(8453);const c={sidebar_position:4},r="Distributed locks",a={id:"advanced/distributed-locks",title:"Distributed locks",description:"Distributed locks are a highly beneficial feature for mitigating race conditions in distributed systems. With the ability of your consumers to scale and operate in parallel, there are scenarios where simultaneous processing of events with the same identifier occurs. For instance, processing multiple instances of Order ID 10452 in parallel can lead to conflicts and race conditions.",source:"@site/docs/advanced/distributed-locks.md",sourceDirName:"advanced",slug:"/advanced/distributed-locks",permalink:"/docs/advanced/distributed-locks",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Async Actions",permalink:"/docs/advanced/async-actions"},next:{title:"Error Handling",permalink:"/docs/advanced/error-handling"}},o={},d=[{value:"Steps to Implement Distributed Locks",id:"steps-to-implement-distributed-locks",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"distributed-locks",children:"Distributed locks"})}),"\n",(0,s.jsx)(t.p,{children:"Distributed locks are a highly beneficial feature for mitigating race conditions in distributed systems. With the ability of your consumers to scale and operate in parallel, there are scenarios where simultaneous processing of events with the same identifier occurs. For instance, processing multiple instances of Order ID 10452 in parallel can lead to conflicts and race conditions."}),"\n",(0,s.jsx)(t.p,{children:"To address this challenge, the Distributed Locks provider can be utilized to ensure that only one process at a time consumes events related to the same entity with the same ID."}),"\n",(0,s.jsx)(t.h3,{id:"steps-to-implement-distributed-locks",children:"Steps to Implement Distributed Locks"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Enable the ",(0,s.jsxs)(t.a,{href:"/docs/advanced/environment-variables#gr_is_distributed_locks_enabled",children:["environment variable ",(0,s.jsx)(t.code,{children:"GR_IS_DISTRIBUTED_LOCKS_ENABLED"})]})," to activate the distributed locks feature."]}),"\n",(0,s.jsxs)(t.li,{children:["Specify one of the two switches in the Namespace Schema to activate the locks:","\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://github.com/ralphv/gallifrey-rules/blob/6bcd2e5b058219de3430b1455c84d94a2e31f0c2/src/lib/NamespaceSchema.ts#L10",children:"$atomicEntity"}),": This switch will lock based on ",(0,s.jsx)(t.code,{children:"Entity Name and Entity ID"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://github.com/ralphv/gallifrey-rules/blob/6bcd2e5b058219de3430b1455c84d94a2e31f0c2/src/lib/NamespaceSchema.ts#L11",children:"$atomicEvent"}),": This switch will lock based on ",(0,s.jsx)(t.code,{children:"Entity Name, Event Name, and Entity ID"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["The typical use case involves locking based on ",(0,s.jsx)(t.code,{children:"Entity Name and Entity ID"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["To activate the ",(0,s.jsx)(t.code,{children:"$atomic*"})," switches across all events, they should be specified at the namespace level."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"By implementing distributed locks, you can effectively synchronize access to resources, thereby preventing race conditions and ensuring data consistency in your distributed applications."})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>a});var s=i(6540);const n={},c=s.createContext(n);function r(e){const t=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(c.Provider,{value:t},e.children)}}}]);